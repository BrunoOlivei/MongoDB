# How to Derive your Data Structure
#DataSchemas #DataModelling

MongoDB aplica a premissa de estruturar os dados baseado na forma como são consultados.

## Quais dados minha aplicação precisa ou gera?
Quais dados são gerados através da aplicação e quais dados são necessários disponibilizar para o usuário na mesma aplicação, **essas perguntas auxiliam estrturar, da melhor forma, os dados.** 

## Onde eu preciso dos meus dados?
Por exemplo um website, onde os dados serão disponibilizados, na página principal, um sessão que lista os produtos ou os pedidos, e quais tipos de dados eu preciso para cada página? 

A idéia é que sejam armazenados os dados no formato necessário na aplicação e se precisar dos mesmo dados em diferentes formatos, pensar em uma estrutura que cubra todos esses casos de uso ou, se absolutamente necessário, dividi-lo em várias coleções

**Essas perguntas definem quais coleções necessários, os campos e como agrupar para que possam se relacionar, quais tipos de dados.**

## Que tipo de dado ou informação será disponível.
Nas diferentes partes da aplicação, quais serão os dados disponibilizados? **Isso define quais consultas serão necessárias**, exemplo, será disponibilizado um produto apenas ou uma lista de produtos (findeOne ou find), estou procurando um produto com um ID especifico?

>[!attention]
>As consultas afetam a forma como se estrutura os dados, portanto é diretamente relacionada as perguntas anteriores.

## Com qual frequência os dados são buscados ou atualizados?
Em todas as páginas carregadas, a cada segundo. Isso define se as buscas devem ser otimizadas.

---

# Relations - Options
- Documentos aninhados ou anexados: endereço de um usuário
```json

{
	userName: "Max",
	age: 29,
	address: {
		street: "Second Street",
		city: "New York"
	}
}
```

- Referências: 
```json
/* User Collections */
{
	userName: "Max",
	favBooks: [
		{name: "Lord of the Ring 1"},
		{name: ...}
		 ]
}

/* Book Collections */	
{
	name: "Lord of the Ring 1"
}


```

A primeira abordagem é válida, porém duplica dados. Se por exemplo, os dados do primeiro livro alterarem, será necessário alterar os dados de todos os clientes que possuam aquele livro.

```json
/* User Collections */
{
	userName: "Max",
	favBooks: ["bookId1", "bookID2"]
}

/* Book Collections */
{
	_id: "bookId1",
	name: "Lord of the Ring 1"
}
```

A segunda abordagem também é válida, porém se um livro for alterado ou atualizado, não há necessidade de alterar todos os registros dos clientes.

## Quando usar qual?
Em uma aplicação para um hosital ou consultório, suponhamos que tenhamos os dados do paciente e os registros de doença de cada um, esses registros são exclusivos de cada paciente e não repetem entre eles.

Esse caso a relação é de 1 para 1 entre o paciente e o seu registro de doenças. 

```javascript
> use hospital

hospital> db.patients.insertOne(
	{
		name: "Max",
		age: 29,
		diseaseSummary: "summary-max-1"
	}
)

{
  acknowledged: true,
  insertedId: ObjectId("62a4ac6b72d684c391755e89")
}

hospital> db.diseaseSummaries.insertOne(
	{
		_id: "summary-max-1",
		disease: ["cold", "broken leg"]
	}
)

{ acknowledged: true, insertedId: 'summary-max-1' }
```

Então temos na coleção patientes, o primeiro paciente, e a coleção diseaseSummaries as queixas, no documento do paciente usamos um ID para relacionar suas queixas.

```json
/* patients */
{
  _id: ObjectId("62a4ac6b72d684c391755e89"),
  name: 'Max',
  age: 29,
  diseaseSummary: 'summary-max-1'
}
```

```json
/* diseaseSummaries */
{ 
	_id: 'summary-max-1', 
	disease: [ 'cold', 'broken leg' ] 
}
```

Agora precisamos disponibilizar os dados do paciente e também suas doenças:

```javascript
hospital> db.patients.findOne({name: "Max"}).diseaseSummary
summary-max-1
```

No Shell do Mongo, podemos utilizar a sintaxe do JavaScript para atribuir a uma variável um valor:

```javascript
hospital> var diseaseId = db.patients.findOne({name: "Max"}).diseaseSummary
```

Podemos verificar se a variável recebeu o valor esperado simplismente executando o nome da variável:

```javascript
hospital> diseaseId
summary-max-1
```

Utilizando o comando findOne passando como valor para a chave ID a variável:

```javascript
hospital> db.diseaseSummaries.findOne({_id: diseaseId})

{ _id: 'summary-max-1', disease: [ 'cold', 'broken leg' ] }
```

Em uma perspectiva de desempenho, essa abordagem leva 2 etapas, para um banco de dados muito grande isso pode ser um problema.
